#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>

const int NUM_REGISTERS = 8;

class Register {
private:
    int value;
public:
    int GetValue() {
        return value;
    }

    void SetValue(int val) {
        value = val;
    }
};

class Memory {
private:
    std::vector<int> memoryStorage;

public:
int ReadMemory(int location) {
        if (location >= 0 && location < memoryStorage.size()) {
            return memoryStorage[location];
        }
        return 0; // Default value for out-of-range memory location
    }

    void WriteMemory(int location, int value) {
        if (location >= 0 && location < memoryStorage.size()) {
            memoryStorage[location] = value;
        }
    }
};
class Screen {
private:
    std::string screenBuffer;

public:
    void AddToScreenBuffer(const std::string& output) {
        screenBuffer += output;
    }
class Instruction {
public:
    virtual void Execute(Register* registers, Memory* memory, Screen* screen) = 0;
    virtual Instruction* Translate(std::string input) = 0;
};

class JumpInstruction : public Instruction {
private:
    int RegisterR;
    int MemoryAddress;

    void DisplayScreen() {
        std::cout << screenBuffer << std::endl;
    }
};
public:
    JumpInstruction(int r, int addr) : RegisterR(r), MemoryAddress(addr) {}

    void Execute(Register* registers, Memory* memory, Screen* screen) override {
        int valueR = registers[RegisterR].GetValue();
        if (valueR == 0) {
            // Set the program counter (PC) to the specified MemoryAddress
            registers[RegisterR].SetValue(MemoryAddress);
        }
    }

    Instruction* Translate(std::string input) override {
        int r, addr;
        std::istringstream(input) >> r >> addr;
        return new JumpInstruction(r, addr);
    }
};
class HaltInstruction : public Instruction {
public:
    void Execute(Register* registers, Memory* memory, Screen* screen) override {
        // Implement the halt operation to stop program execution
    }

    Instruction* Translate(std::string input) override {
        // Implement translation of the Halt instruction
        // This instruction has no additional parameters
        return new HaltInstruction();
    }
};
class MoveInstruction : public Instruction {
private:
    int RegisterR;
    int RegisterS;

public:
    MoveInstruction(int r, int s) : RegisterR(r), RegisterS(s) {}

    void Execute(Register* registers, Memory* memory, Screen* screen) override {
        int value = registers[RegisterR].GetValue();
        registers[RegisterS].SetValue(value);
    }

    Instruction* Translate(std::string input) override {
        int r, s;
        std::istringstream(input) >> r >> s;
        return new MoveInstruction(r, s);
    }
};
class AddInstruction : public Instruction {
private:
    int RegisterR;
    int RegisterS;
    int RegisterT;

public:
    AddInstruction(int r, int s, int t) : RegisterR(r), RegisterS(s), RegisterT(t) {}

    void Execute(Register* registers, Memory* memory, Screen* screen) override {
        int valueS = registers[RegisterS].GetValue();
        int valueT = registers[RegisterT].GetValue();
        int sum = valueS + valueT;
        registers[RegisterR].SetValue(sum);
    }

    Instruction* Translate(std::string input) override {
        int r, s, t;
        std::istringstream(input) >> r >> s >> t;
        return new AddInstruction(r, s, t);
    }
};

