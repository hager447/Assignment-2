#include "BigReal.h"
#include <bits/stdc++.h>
using namespace std;

// constructors

BigReal::BigReal( double x ) {
    BigReal temp(to_string(x)) ;
    isNegative = temp.isNegative ;
    INPUT = temp.INPUT ;
}

BigReal::BigReal(string realNumber) {
    L_R_Strip(realNumber) ;
    if ( realNumber.front() == '-' )
        isNegative = true ;
    else
        isNegative = false ;
    if ( realNumber.front() == '-' || realNumber.front() == '+' )
        INPUT = realNumber.substr(1) ;
    else
        INPUT = realNumber ;
    if (INPUT.find('.') == -1 )
        INPUT.push_back('.') ;
}
BigReal::BigReal(string new_num, bool Sign) {
    INPUT = new_num ;
    isNegative = Sign ;
}
BigReal::BigReal(const BigReal &other) {
    INPUT = other.INPUT ;
    isNegative = other.isNegative ;
}
bool BigReal ::isValidReal (string number){
    if (count(number.begin(), number.end(),'.')>1||
        count(number.begin(), number.end(),' ')>0||number[1]=='+'||number[1]=='-') {
        return false ;
    }
    return true ;
}

void BigReal::L_R_Strip(string &text) {
    while ( text.back() == '0' )
        text.pop_back() ;
    int k = 0 ;
    while ( text[k] == '0' ) k++ ;
    text = text.substr(k) ;
    if ( text.front() == '.' )
        text = '0' + text ;
}

pair<string, string> BigReal::append_zero( string num1 , string num2 ) {
    int app1_r = 0 , app2_r = 0 , app1_l = 0 , app2_l = 0 ;
    app1_r = max(0, (int) ((num2.size() - num2.find('.')) - (num1.size() - num1.find('.'))));
    app2_r = max(0, (int) ((num1.size() - num1.find('.')) - (num2.size() - num2.find('.'))));
    app1_l = max(0, (int) (num2.find('.') - num1.find('.')));
    app2_l = max(0, (int) (num1.find('.') - num2.find('.')));
    num1 =  (string(app1_l , '0') + num1 + string(  app1_r , '0' )) ;
    num2 =  (string(app2_l , '0') + num2 + string(  app2_r , '0' )) ;
    return { num1 , num2 } ;
}
stream &operator<<(ostream &out, const BigReal &num) {
    if ( num.isNegative ) cout << '-' ;
    if ( num.INPUT.back() == '.' )
        cout << num.INPUT.substr(0 , num.INPUT.size() - 1 ) ;
    else
        cout << num.INPUT ;
    return out ;
}

bool BigReal::operator==(const BigReal &anotherReal) {
    return ( isNegative == isNegative && INPUT == anotherReal.INPUT ) ;
}

bool BigReal::operator>(const BigReal &anotherReal) {
    if ( anotherReal.isNegative && !isNegative ){
        return true ;
    }
    if ( !anotherReal.isNegative && isNegative ){
        return false ;
    }
    pair<string,string> cmp = append_zero( INPUT , anotherReal.INPUT ) ;
    if ( anotherReal.isNegative == isNegative && isNegative ){
        if ( cmp.first.compare(cmp.second ) < 0 ){
            return true ;
        } else {
            return false ;
        }
    }
    if ( anotherReal.isNegative == isNegative && !isNegative){
        if ( cmp.first.compare(cmp.second ) > 0 ) {
            return true ;
        } else {
            return false ;
        }
    }
}


